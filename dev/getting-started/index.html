<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · SolePostHoc.jl</title><meta name="title" content="Getting started · SolePostHoc.jl"/><meta property="og:title" content="Getting started · SolePostHoc.jl"/><meta property="twitter:title" content="Getting started · SolePostHoc.jl"/><meta name="description" content="Documentation for SolePostHoc.jl."/><meta property="og:description" content="Documentation for SolePostHoc.jl."/><meta property="twitter:description" content="Documentation for SolePostHoc.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SolePostHoc.jl/getting-started/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SolePostHoc.jl/getting-started/"/><link rel="canonical" href="https://aclai-lab.github.io/SolePostHoc.jl/getting-started/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SolePostHoc.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Fast-introduction"><span>Fast introduction</span></a></li><li><a class="tocitem" href="#Core-definitions"><span>Core definitions</span></a></li><li><a class="tocitem" href="#Algorithm-Types"><span>Algorithm Types</span></a></li><li><a class="tocitem" href="#Direct-Algorithm-Access"><span>Direct Algorithm Access</span></a></li><li><a class="tocitem" href="#Rule-Extraction,-simplification-and-Optimization"><span>Rule Extraction, simplification and Optimization</span></a></li><li><a class="tocitem" href="#Customization-and-Extension"><span>Customization and Extension</span></a></li><li><a class="tocitem" href="#Integration-with-Sole.jl-Ecosystem"><span>Integration with Sole.jl Ecosystem</span></a></li></ul></li><li><a class="tocitem" href="../extract-algorithms/">Extract with algorithms</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SolePostHoc.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/main/docs/src/getting-started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="getting-started"><a class="docs-heading-anchor" href="#getting-started">Getting started</a><a id="getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#getting-started" title="Permalink"></a></h1><p>In this introductory section, you will learn about the main building blocks of SolePostHoc.jl. The above introduces two important ideas for using post-hoc explanation algorithms. Further on in the documentation, the potential of SolePostHoc.jl will become apparent: this package&#39;s primary purpose is to provide a uniform interface for knowledge extraction algorithms, enabling the comparison of different post-hoc interpretation methods while maintaining a coherent and intuitive user experience.</p><h2 id="Fast-introduction"><a class="docs-heading-anchor" href="#Fast-introduction">Fast introduction</a><a id="Fast-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-introduction" title="Permalink"></a></h2><p>Consider a machine learning model trained on a generic dataset. For example, let us consider a Random Forest Classifier learned on the <a href="https://www.kaggle.com/datasets/uciml/iris">Iris</a> dataset to classify 3 different species of flowers. We are interested in extracting interpretable rules that explain the model&#39;s decision process. SolePostHoc.jl offers two primary methods for accomplishing this task.</p><p>The first approach is to directly call the specific algorithm function. For example:</p><pre><code class="language-julia hljs"># Extract rules using the LUMEN algorithm directly
extracted_rules = lumen(model, X_test, y_test, args...)</code></pre><p>The second approach uses the unified interface through rule extractors:</p><pre><code class="language-julia hljs"># Extract rules using the unified interface
extractor = LumenRuleExtractor()
decision_set = modalextractrules(extractor, model, X_test, y_test, args...)</code></pre><p>The key advantage of the second approach is that it not only executes the original algorithm (equivalent to calling <code>lumen(...)</code> directly) but also converts the output into a <code>DecisionSet</code>. A <code>DecisionSet</code> is a vector of propositional logical rules in Disjunctive Normal Form (DNF), with one rule per class/label.</p><p>Consider a trained model that classifies hand gestures. Using SolePostHoc.jl, we might extract the following decision set:</p><pre><code class="nohighlight hljs">Class &quot;Iris-setosa&quot;: IF (SepalLengthCm &lt; -0.5) AND (SepalWidthCm &lt; 8.2) THEN predict &quot;Iris-setosa&quot;
Class &quot;Iris-versicolor&quot;: IF (SepalLengthCm &gt; 0.5) AND (SepalWidthCm &lt; 3.25) THEN predict &quot;Iris-versicolor&quot;
Class &quot;Iris-virginica&quot;: IF (PetalWidthCm &gt; 2.0) THEN predict &quot;Iris-virginica&quot;</code></pre><h2 id="Core-definitions"><a class="docs-heading-anchor" href="#Core-definitions">Core definitions</a><a id="Core-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-definitions" title="Permalink"></a></h2><p>The foundation of SolePostHoc.jl lies in providing interpretable explanations for complex machine learning models through rule extraction.</p><pre><code class="language-julia hljs">abstract type RuleExtractor</code></pre><p>A <code>RuleExtractor</code> is an abstract type that defines the interface for all post-hoc explanation algorithms. Each concrete implementation represents a specific knowledge extraction method.</p><p>A <code>DecisionSet</code> represents the extracted knowledge as a collection of logical rules, where each rule corresponds to a specific class or decision outcome in Disjunctive Normal Form.</p><p>The main entry point for rule extraction is:</p><pre><code class="language-julia hljs">modalextractrules(extractor::RuleExtractor, model, args...)</code></pre><h2 id="Algorithm-Types"><a class="docs-heading-anchor" href="#Algorithm-Types">Algorithm Types</a><a id="Algorithm-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Types" title="Permalink"></a></h2><p>SolePostHoc.jl integrates a wide range of algorithms for knowledge extraction, categorized into three main types:</p><h3 id="Surrogate-Trees"><a class="docs-heading-anchor" href="#Surrogate-Trees">Surrogate Trees</a><a id="Surrogate-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Surrogate-Trees" title="Permalink"></a></h3><p>Algorithms that approximate complex models such as neural networks or random forests with more interpretable decision trees.</p><pre><code class="language-julia hljs">struct REFNERuleExtractor &lt;: RuleExtractor end
struct BATreesRuleExtractor &lt;: RuleExtractor end 
struct TREPANRuleExtractor &lt;: RuleExtractor end</code></pre><h3 id="Knowledge-Distillation"><a class="docs-heading-anchor" href="#Knowledge-Distillation">Knowledge Distillation</a><a id="Knowledge-Distillation-1"></a><a class="docs-heading-anchor-permalink" href="#Knowledge-Distillation" title="Permalink"></a></h3><p>Techniques for transferring knowledge from complex models (teacher) to simpler and more transparent ones (student).</p><pre><code class="language-julia hljs">struct RuleCOSIPLUSRuleExtractor &lt;: RuleExtractor end
struct InTreesRuleExtractor &lt;: RuleExtractor end</code></pre><h3 id="Rule-Extraction"><a class="docs-heading-anchor" href="#Rule-Extraction">Rule Extraction</a><a id="Rule-Extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Extraction" title="Permalink"></a></h3><p>Methods for deriving clear and understandable logical rules from any machine learning model.</p><pre><code class="language-julia hljs">struct LUMENRuleExtractor &lt;: RuleExtractor end</code></pre><h2 id="Direct-Algorithm-Access"><a class="docs-heading-anchor" href="#Direct-Algorithm-Access">Direct Algorithm Access</a><a id="Direct-Algorithm-Access-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Algorithm-Access" title="Permalink"></a></h2><p>For users who prefer to use algorithms in their original form without the unified interface, SolePostHoc.jl provides direct access to each algorithm:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.intrees" href="#SolePostHoc.RuleExtraction.intrees"><code>SolePostHoc.RuleExtraction.intrees</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intrees(model::Union{AbstractModel,DecisionForest}, X, y::AbstractVector{&lt;:Label}; kwargs...)::DecisionList</code></pre><p>Return a decision list which approximates the behavior of the input <code>model</code> on the specified supervised dataset. The set of relevant and non-redundant rules in the decision list are obtained by means of rule selection, rule pruning, and sequential covering (STEL).</p><p><strong>References</strong></p><ul><li>Deng, Houtao. &quot;Interpreting tree ensembles with intrees.&quot; International Journal of Data Science and Analytics 7.4 (2019): 277-287.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>prune_rules::Bool=true</code>: access to prune or not</li><li><code>pruning_s::Union{Float64,Nothing}=nothing</code>: parameter that limits the denominator in the pruning metric calculation</li><li><code>pruning_decay_threshold::Union{Float64,Nothing}=nothing</code>: threshold used in pruning to remove or not a joint from the rule</li><li><code>rule_selection_method::Symbol=:CBC</code>: rule selection method. Currently only supports <code>:CBC</code></li><li><code>rule_complexity_metric::Symbol=:natoms</code>: Metric to use for estimating a rule complexity measure</li><li><code>max_rules::Int=-1</code>: maximum number of rules in the final decision list (excluding default rule). Use -1 for unlimited rules.</li><li><code>min_coverage::Union{Float64,Nothing}=nothing</code>: minimum rule coverage for STEL</li><li>See <a href="@ref"><code>modalextractrules</code></a> keyword arguments...</li></ul><p>Although the method was originally presented for forests it is hereby extended to work with any symbolic models.</p><p>See also <a href="@ref"><code>AbstractModel</code></a>, <a href="@ref"><code>DecisionList</code></a>, <a href="@ref"><code>listrules</code></a>, <a href="@ref"><code>rulemetrics</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/8a4d3e7fb548c9464397795f4c0c601c85f7fcde/src/intrees/intrees.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.Lumen.lumen" href="#SolePostHoc.RuleExtraction.Lumen.lumen"><code>SolePostHoc.RuleExtraction.Lumen.lumen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lumen(model; config_args...) -&gt; LumenResult
lumen(model, config::LumenConfig) -&gt; LumenResult</code></pre><p>Logic-driven Unified Minimal Extractor of Notions (LUMEN): Extract and minimize logical rules from decision tree models into interpretable DNF formulas.</p><p>LUMEN implements a comprehensive pipeline for converting decision tree models into interpretable logical rules. The algorithm extracts the underlying decision logic, constructs truth tables, and applies advanced minimization techniques to produce compact, human-readable rule sets.</p><p><strong>Method Signatures</strong></p><p><strong>Keyword Arguments Interface</strong></p><pre><code class="language-julia hljs">lumen(model; minimization_scheme=:mitespresso, vertical=1.0, horizontal=1.0, ...)</code></pre><p>Convenient interface using keyword arguments with automatic config construction.</p><p><strong>Configuration Object Interface</strong></p><pre><code class="language-julia hljs">lumen(model, config::LumenConfig)</code></pre><p>Advanced interface using pre-constructed configuration for complex scenarios.</p><p><strong>Arguments</strong></p><p><strong>Required Arguments</strong></p><ul><li><code>model</code>: Decision tree model to analyze<ul><li><strong>Single trees</strong>: Individual decision tree models</li><li><strong>Ensembles</strong>: Random forests, gradient boosting, etc.</li><li><strong>Supported formats</strong>: DecisionTree.jl, SoleModels framework</li></ul></li></ul><p><strong>Configuration (via keywords or LumenConfig)</strong></p><ul><li><code>minimization_scheme::Symbol = :mitespresso</code>: DNF minimization algorithm</li><li><code>vertical::Float64 = 1.0</code>: Instance coverage parameter α ∈ (0,1]</li><li><code>depth::Float64 = 1.0</code>: Depth coverage parameter δ ∈ (0,1]</li><li><code>horizontal::Float64 = 1.0</code>: Feature coverage parameter β ∈ (0,1]</li><li><code>ott_mode::Bool = false</code>: Enable memory-optimized processing</li><li><code>silent::Bool = false</code>: Suppress progress output</li><li><code>return_info::Bool = true</code>: Include detailed metadata in results</li></ul><p><strong>Returns</strong></p><p><code>LumenResult</code> containing:</p><ul><li><strong><code>decision_set</code></strong>: Collection of minimized logical rules</li><li><strong><code>info</code></strong>: Metadata including statistics and unminimized rules</li><li><strong><code>processing_time</code></strong>: Total algorithm execution time</li></ul><p><strong>Algorithm Pipeline</strong></p><p><strong>Phase 1: Model Analysis and Rule Extraction</strong></p><pre><code class="nohighlight hljs">Input Model → Rule Extraction → Logical Rule Set</code></pre><ul><li>Analyzes model structure (single tree vs ensemble)</li><li>Extracts decision paths as logical rules</li><li>Handles different model types with appropriate strategies</li></ul><p><strong>Phase 2: Alphabet Construction and Atom Processing</strong></p><pre><code class="nohighlight hljs">Logical Rules → Atom Extraction → Logical Alphabet</code></pre><ul><li>Identifies atomic logical conditions</li><li>Constructs vocabulary for formula building</li><li>Validates feature support and operator compatibility</li></ul><p><strong>Phase 3: Truth Table Generation</strong></p><pre><code class="nohighlight hljs">Model + Alphabet → Truth Combinations → Labeled Examples</code></pre><ul><li>Generates systematic input combinations</li><li>Evaluates model on each combination</li><li>Creates correspondence between inputs and outputs</li></ul><p><strong>Phase 4: DNF Construction and Minimization</strong></p><pre><code class="nohighlight hljs">Truth Table → DNF Formulas → Minimized Rules</code></pre><ul><li>Constructs DNF formulas for each decision class</li><li>Applies advanced minimization algorithms</li><li>Converts back to interpretable rule format</li></ul><p><strong>Performance Characteristics</strong></p><p><strong>Computational Complexity</strong></p><ul><li><strong>Time</strong>: O(2^k × n × d) where k=features, n=instances, d=tree depth</li><li><strong>Space</strong>: O(k × r) where r=number of rules</li><li><strong>Scalability</strong>: Optimized modes available for large datasets</li></ul><p><strong>Memory Usage</strong></p><ul><li><strong>Standard mode</strong>: Suitable for typical datasets (&lt; 20 features)</li><li><strong>Optimized mode</strong>: Memory-efficient processing for large problems</li><li><strong>Streaming capability</strong>: Future versions may support streaming processing</li></ul><p><strong>Advanced Features</strong></p><p><strong>Custom Processing</strong></p><pre><code class="language-julia hljs"># Custom alphabet filtering for domain expertise
custom_filter = alphabet -&gt; remove_irrelevant_features(alphabet)
config = LumenConfig(filteralphabetcallback = custom_filter)
result = lumen(model, config)</code></pre><p><strong>Performance Tuning</strong></p><pre><code class="language-julia hljs"># Memory-optimized processing for large datasets
config = LumenConfig(ott_mode = true, vertical = 0.8)

# Speed-optimized processing with basic minimization
config = LumenConfig(minimization_scheme = :abc, silent = true)</code></pre><p><strong>Analysis and Debugging</strong></p><pre><code class="language-julia hljs"># Full information retention for analysis
config = LumenConfig(return_info = true, controllo = true)
result = lumen(model, config)

# Access detailed statistics
println(&quot;Rules before minimization: _(length(result.info.unminimized_ds.rules))&quot;)
println(&quot;Rules after minimization: _(length(result.decision_set.rules))&quot;)</code></pre><p><strong>Error Handling</strong></p><p>The algorithm implements comprehensive error handling:</p><p><strong>Configuration Validation</strong></p><ul><li>Parameter range checking (coverage parameters must be ∈ (0,1])</li><li>Algorithm availability verification</li><li>Consistency validation across parameters</li></ul><p><strong>Processing Errors</strong></p><ul><li>Graceful handling of minimization failures</li><li>Fallback strategies for problematic formulas</li><li>Detailed error reporting with context</li></ul><p><strong>Model Compatibility</strong></p><ul><li>Automatic detection of supported model types</li><li>Clear error messages for unsupported formats</li><li>Suggestions for model preprocessing</li></ul><p><strong>Examples</strong></p><p><strong>Basic Usage</strong></p><pre><code class="language-julia hljs"># Simple rule extraction with default settings
model = build_tree(X, y)
result = lumen(model)
println(&quot;Extracted _(length(result.decision_set.rules)) rules&quot;)</code></pre><p><strong>Advanced Configuration</strong></p><pre><code class="language-julia hljs"># Customized processing for complex scenarios
config = LumenConfig(
    minimization_scheme = :boom,        # Aggressive minimization
    vertical = 0.9,                     # High instance coverage
    depth = 0.7,                        # Moderate depth coverage
    horizontal = 0.8,                   # Moderate feature coverage
    ott_mode = true,                    # Memory optimization
    return_info = true                  # Full information retention
)
result = lumen(large_ensemble, config)</code></pre><p><strong>Performance Analysis</strong></p><pre><code class="language-julia hljs"># Detailed performance and quality analysis
result = lumen(model, LumenConfig(return_info = true))

# Analyze minimization effectiveness
stats = result.info.vectPrePostNumber
total_reduction = sum(pre - post for (pre, post) in stats)
avg_compression = mean(pre / post for (pre, post) in stats)

println(&quot;Total term reduction: total_reduction&quot;)
println(&quot;Average compression ratio: (round(avg_compression, digits=2))x&quot;)
println(&quot;Processing time: _(result.processing_time) seconds&quot;)</code></pre><p><strong>Implementation Notes</strong></p><p><strong>Design Principles</strong></p><ol><li><strong>Modularity</strong>: Each phase is independently testable and extensible</li><li><strong>Configurability</strong>: Extensive customization without code modification</li><li><strong>Performance</strong>: Multiple optimization strategies for different scenarios</li><li><strong>Robustness</strong>: Comprehensive error handling and validation</li><li><strong>Usability</strong>: Clean interfaces with sensible defaults</li></ol><p><strong>Extensibility Points</strong></p><ul><li><strong>New minimization algorithms</strong>: Add via Val() dispatch system</li><li><strong>Custom model types</strong>: Extend rule extraction strategies</li><li><strong>Domain-specific processing</strong>: Custom alphabet filters and apply functions</li><li><strong>Output formats</strong>: Additional result formatters and exporters</li></ul><p>See also: <a href="../extract-algorithms/#SolePostHoc.RuleExtraction.Lumen.LumenConfig"><code>LumenConfig</code></a>, <a href="../extract-algorithms/#SolePostHoc.RuleExtraction.Lumen.LumenResult"><code>LumenResult</code></a>, <a href="@ref"><code>extract_rules</code></a>, <a href="@ref"><code>minimize_formula</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/8a4d3e7fb548c9464397795f4c0c601c85f7fcde/src/lumen/main.jl#L1626-L1826">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.BATrees.batrees" href="#SolePostHoc.RuleExtraction.BATrees.batrees"><code>SolePostHoc.RuleExtraction.BATrees.batrees</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">batrees(f; dataset_name=&quot;iris&quot;, num_trees=10, max_depth=10, dsOutput=true)</code></pre><p>Builds and trains a set of binary decision trees OR using the specified function <code>f</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: An SoleForest.</li><li><code>dataset_name::String</code>: The name of the dataset to be used. Default is &quot;iris&quot;.</li><li><code>num_trees::Int</code>: The number of trees to be built. Default is 10.</li><li><code>max_depth::Int</code>: The maximum depth of each tree. Default is 10.</li><li><code>dsOutput::Bool</code>: A flag indicating whether to return the dsStruct output. Default is true. if false, returns the result single tree.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>dsOutput</code> is true, returns the result is in DecisionSet ds.</li><li>If <code>dsOutput</code> is false, returns the result is SoleTree t`.</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/8a4d3e7fb548c9464397795f4c0c601c85f7fcde/src/BA-Trees/src/main.jl#L14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.REFNE.refne" href="#SolePostHoc.RuleExtraction.REFNE.refne"><code>SolePostHoc.RuleExtraction.REFNE.refne</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refne(m, Xmin, Xmax; L=100, perc=1.0, max_depth=-1, n_subfeatures=-1, 
      partial_sampling=0.7, min_samples_leaf=5, min_samples_split=2, 
      min_purity_increase=0.0, seed=3)</code></pre><p>Extract interpretable rules from a trained neural network ensemble using decision tree approximation.</p><p>This implementation follows the REFNE-a (Rule Extraction From Neural Network Ensemble) algorithm, which approximates complex neural network behavior with an interpretable decision tree model.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: Trained neural network model to extract rules from</li><li><code>Xmin</code>: Minimum values for each input feature</li><li><code>Xmax</code>: Maximum values for each input feature</li><li><code>L</code>: Number of samples to generate in the synthetic dataset (default: 100)</li><li><code>perc</code>: Percentage of generated samples to use (default: 1.0)</li><li><code>max_depth</code>: Maximum depth of the decision tree (default: -1, unlimited)</li><li><code>n_subfeatures</code>: Number of features to consider at each split (default: -1, all)</li><li><code>partial_sampling</code>: Fraction of samples used for each tree (default: 0.7)</li><li><code>min_samples_leaf</code>: Minimum number of samples required at a leaf node (default: 5)</li><li><code>min_samples_split</code>: Minimum number of samples required to split a node (default: 2)</li><li><code>min_purity_increase</code>: Minimum purity increase required for a split (default: 0.0)</li><li><code>seed</code>: Random seed for reproducibility (default: 3)</li></ul><p><strong>Returns</strong></p><ul><li>A forest-decision trees representing the extracted rules</li></ul><p><strong>Description</strong></p><p>The algorithm works by:</p><ol><li>Generating a synthetic dataset spanning the input space</li><li>Using the neural network to label these samples</li><li>Training a decision tree to approximate the neural network&#39;s behavior</li></ol><p><strong>References</strong></p><ul><li>Zhi-Hua, Zhou, et al. Extracting Symbolic Rules from Trained Neural Network Ensembles</li></ul><p><strong>Example</strong></p><p>```julia model = load<em>decision</em>tree_model() refne(model, Xmin, Xmax)</p><p>See also <a href="@ref"><code>AbstractModel</code></a>, <a href="@ref"><code>DecisionList</code></a>, <a href="@ref"><code>listrules</code></a>, <a href="@ref"><code>rulemetrics</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/8a4d3e7fb548c9464397795f4c0c601c85f7fcde/src/Refne/src/main.jl#L23-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.TREPAN.trepan" href="#SolePostHoc.RuleExtraction.TREPAN.trepan"><code>SolePostHoc.RuleExtraction.TREPAN.trepan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><ul><li>Mark W. Craven, et al. &quot;Extracting Thee-Structured Representations of Thained Networks&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/8a4d3e7fb548c9464397795f4c0c601c85f7fcde/src/Trepan/src/main.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.RULECOSIPLUS.rulecosiplus" href="#SolePostHoc.RuleExtraction.RULECOSIPLUS.rulecosiplus"><code>SolePostHoc.RuleExtraction.RULECOSIPLUS.rulecosiplus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rulecosiplus(ensemble::Any, X_train::Any, y_train::Any)</code></pre><p>Extract interpretable rules from decision tree ensembles using the RuleCOSI+ algorithm.</p><p>This function implements the RuleCOSI+ methodology for rule extraction from trained ensemble  classifiers, producing a simplified and interpretable rule-based model. The method combines  and simplifies rules extracted from individual trees in the ensemble to create a more  compact and understandable decision list.</p><p><strong>Reference</strong></p><p>Obregon, J. (2022). RuleCOSI+: Rule extraction for interpreting classification tree ensembles.  <em>Information Fusion</em>, 89, 355-381.  Available at: https://www.sciencedirect.com/science/article/pii/S1566253522001129</p><p><strong>Arguments</strong></p><ul><li><code>ensemble::Any</code>: A trained ensemble classifier (e.g., Random Forest, Gradient Boosting)  that will be serialized and converted to a compatible format for rule extraction.</li><li><code>X_train::Any</code>: Training feature data. Can be a DataFrame or Matrix. If DataFrame,  column names will be preserved in the extracted rules; otherwise, generic names (V1, V2, ...)  will be generated.</li><li><code>y_train::Any</code>: Training target labels corresponding to <code>X_train</code>. Will be converted to  string format for processing.</li></ul><p><strong>Returns</strong></p><ul><li><code>DecisionList</code>: A simplified decision list containing the extracted and combined rules  from the ensemble, suitable for interpretable classification.</li></ul><p><strong>Details</strong></p><p>The function performs the following steps:</p><ol><li>Converts input data to appropriate matrix format</li><li>Generates or extracts feature column names</li><li>Serializes the Julia ensemble to a Python-compatible format</li><li>Builds an sklearn-compatible model using the serialized ensemble</li><li>Applies RuleCOSI+ algorithm with the following default parameters:<ul><li><code>metric=&quot;fi&quot;</code>: Optimization metric for rule combination</li><li><code>n_estimators=100</code>: Number of estimators considered</li><li><code>tree_max_depth=100</code>: Maximum depth of trees</li><li><code>conf_threshold=0.25</code> (α): Confidence threshold for rule filtering</li><li><code>cov_threshold=0.1</code> (β): Coverage threshold for rule filtering</li><li><code>verbose=2</code>: Detailed output during processing</li></ul></li><li>Extracts and converts rules to a decision list format</li></ol><p><strong>Configuration</strong></p><p>The algorithm uses fixed parameters optimized for interpretability:</p><ul><li>Confidence threshold (α) = 0.25: Rules below this confidence are discarded</li><li>Coverage threshold (β) = 0.1: Rules covering fewer samples are excluded</li><li>Maximum rules = max(20, n_classes × 5): Adaptive limit based on problem complexity</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Assuming you have a trained ensemble and training data
ensemble = ... # your trained ensemble
X_train = ... # training features
y_train = ... # training labels

# Extract interpretable rules
decision_list = rulecosiplus(ensemble, X_train, y_train)</code></pre><p><strong>Notes</strong></p><ul><li>The function prints diagnostic information including the number of trees and dataset statistics</li><li>Raw rules are displayed before conversion to decision list format</li><li>Requires Python interoperability and the RuleCOSI implementation</li><li>The resulting decision list provides an interpretable alternative to the original ensemble</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/8a4d3e7fb548c9464397795f4c0c601c85f7fcde/src/RuleCosiplus/src/main.jl#L374-L439">source</a></section></article><h2 id="Rule-Extraction,-simplification-and-Optimization"><a class="docs-heading-anchor" href="#Rule-Extraction,-simplification-and-Optimization">Rule Extraction, simplification and Optimization</a><a id="Rule-Extraction,-simplification-and-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Extraction,-simplification-and-Optimization" title="Permalink"></a></h2><p>One of the key features of SolePostHoc.jl is its ability to extract, simplify and optimize extracted rules while maintaining their expressiveness.</p><p>For example, consider this decision forest:</p><pre><code class="nohighlight hljs">├[1/2]┐ (V3 &lt; 2.45)
│     ├✔ Iris-setosa
│     └✘ (V4 &lt; 1.75)
│       ├✔ (V3 &lt; 4.65)
│       │ ├✔ Iris-versicolor
│       │ └✘ Iris-versicolor
│       └✘ Iris-virginica
└[2/2]┐ (V4 &lt; 0.8)
      ├✔ Iris-setosa
      └✘ (V1 &lt; 5.65)
        ├✔ (V4 &lt; 1.2)
        │ ├✔ Iris-versicolor
        │ └✘ Iris-versicolor
        └✘ (V3 &lt; 4.75)
          ├✔ Iris-versicolor
          └✘ Iris-virginica</code></pre><p>SolePostHoc.jl can leverage logical reasoning to obtain a more succinct and equally expressive theory:</p><pre><code class="nohighlight hljs">▣
├[1/3] ((V3 ≥ 2.45) ∧ (V4 ≥ 1.75)) ∨ ((V1 ≥ 5.65) ∧ (V3 ≥ 4.75) ∧ (V4 ≥ 0.8))  ↣  Iris-virginica
├[2/3] ((V3 ≥ 2.45) ∧ (V3 &lt; 4.65) ∧ (V4 &lt; 1.75)) ∨ ((V3 ≥ 4.65) ∧ (V3 &lt; 4.75) ∧ (V4 &lt; 1.75)) ∨ ((V1 &lt; 5.65) ∧ (V3 ≥ 4.65) ∧ (V4 &lt; 1.75)) ∨ ((V3 ≥ 2.45) ∧ (V4 &lt; 0.8))  ↣  Iris-versicolor
└[3/3] (V3 &lt; 2.45)  ↣  Iris-setosa
</code></pre><h2 id="Customization-and-Extension"><a class="docs-heading-anchor" href="#Customization-and-Extension">Customization and Extension</a><a id="Customization-and-Extension-1"></a><a class="docs-heading-anchor-permalink" href="#Customization-and-Extension" title="Permalink"></a></h2><p>Users can implement their own rule extraction algorithms by extending the <code>RuleExtractor</code> interface:</p><pre><code class="language-julia hljs">
function algorithm(model, args...)
    # ordinary function
    return output  # regular generic type of output
end

struct MyCustomExtractor &lt;: RuleExtractor
    # algorithm-specific parameters
end

function modalextractrules(extractor::MyCustomExtractor, model, args...)
    # implement your custom convert `generic type of output in decision set` logic
    # return a DecisionSet
end</code></pre><h2 id="Integration-with-Sole.jl-Ecosystem"><a class="docs-heading-anchor" href="#Integration-with-Sole.jl-Ecosystem">Integration with Sole.jl Ecosystem</a><a id="Integration-with-Sole.jl-Ecosystem-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Sole.jl-Ecosystem" title="Permalink"></a></h2><p>SolePostHoc.jl seamlessly integrates with the broader Sole.jl ecosystem, particularly:</p><ul><li><strong>SoleLogics.jl</strong>: For modal logic reasoning and formula manipulation</li><li><strong>SoleData.jl</strong>: For handling multivariate time series and relational data structures</li><li><strong>SoleModels.jl</strong>: For interpretable model training and symbolic learning</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../extract-algorithms/">Extract with algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Monday 27 October 2025 07:59">Monday 27 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
