<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extract with algorithms · SolePostHoc.jl</title><meta name="title" content="Extract with algorithms · SolePostHoc.jl"/><meta property="og:title" content="Extract with algorithms · SolePostHoc.jl"/><meta property="twitter:title" content="Extract with algorithms · SolePostHoc.jl"/><meta name="description" content="Documentation for SolePostHoc.jl."/><meta property="og:description" content="Documentation for SolePostHoc.jl."/><meta property="twitter:description" content="Documentation for SolePostHoc.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SolePostHoc.jl/extract-algorithms/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SolePostHoc.jl/extract-algorithms/"/><link rel="canonical" href="https://aclai-lab.github.io/SolePostHoc.jl/extract-algorithms/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SolePostHoc.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Extract with algorithms</a><ul class="internal"><li><a class="tocitem" href="#Rule-Extraction-Methods"><span>Rule Extraction Methods</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Extract with algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extract with algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SolePostHoc.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/main/docs/src/extract-algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Rule-Extraction-Methods"><a class="docs-heading-anchor" href="#Rule-Extraction-Methods">Rule Extraction Methods</a><a id="Rule-Extraction-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Extraction-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.intrees-Tuple{Any, Any, AbstractVector{&lt;:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}" href="#SolePostHoc.RuleExtraction.intrees-Tuple{Any, Any, AbstractVector{&lt;:Union{AbstractString, Real, Symbol, CategoricalArrays.CategoricalValue}}}"><code>SolePostHoc.RuleExtraction.intrees</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intrees(model::Union{AbstractModel,DecisionForest}, X, y::AbstractVector{&lt;:Label}; kwargs...)::DecisionList</code></pre><p>Return a decision list which approximates the behavior of the input <code>model</code> on the specified supervised dataset. The set of relevant and non-redundant rules in the decision list are obtained by means of rule selection, rule pruning, and sequential covering (STEL).</p><p><strong>References</strong></p><ul><li>Deng, Houtao. &quot;Interpreting tree ensembles with intrees.&quot; International Journal of Data Science and Analytics 7.4 (2019): 277-287.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>prune_rules::Bool=true</code>: access to prune or not</li><li><code>pruning_s::Union{Float64,Nothing}=nothing</code>: parameter that limits the denominator in the pruning metric calculation</li><li><code>pruning_decay_threshold::Union{Float64,Nothing}=nothing</code>: threshold used in pruning to remove or not a joint from the rule</li><li><code>rule_selection_method::Symbol=:CBC</code>: rule selection method. Currently only supports <code>:CBC</code></li><li><code>rule_complexity_metric::Symbol=:natoms</code>: Metric to use for estimating a rule complexity measure</li><li><code>max_rules::Int=-1</code>: maximum number of rules in the final decision list (excluding default rule). Use -1 for unlimited rules.</li><li><code>min_coverage::Union{Float64,Nothing}=nothing</code>: minimum rule coverage for STEL</li><li>See <a href="@ref"><code>modalextractrules</code></a> keyword arguments...</li></ul><p>Although the method was originally presented for forests it is hereby extended to work with any symbolic models.</p><p>See also <a href="@ref"><code>AbstractModel</code></a>, <a href="@ref"><code>DecisionList</code></a>, <a href="@ref"><code>listrules</code></a>, <a href="@ref"><code>rulemetrics</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/intrees/intrees.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.BATreesRuleExtractor" href="#SolePostHoc.RuleExtraction.BATreesRuleExtractor"><code>SolePostHoc.RuleExtraction.BATreesRuleExtractor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract rules from a symbolic model using <a href="ref"><code>batrees</code></a>.</p><p>See also <a href="@ref"><code>modalextractrules</code></a>, <a href="@ref"><code>RuleExtractor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/rule-extraction.jl#L102-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.InTreesRuleExtractor" href="#SolePostHoc.RuleExtraction.InTreesRuleExtractor"><code>SolePostHoc.RuleExtraction.InTreesRuleExtractor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract rules from a symbolic model using <a href="ref"><code>intrees</code></a>.</p><p>See also <a href="@ref"><code>modalextractrules</code></a>, <a href="@ref"><code>RuleExtractor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/rule-extraction.jl#L51-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.LumenRuleExtractor" href="#SolePostHoc.RuleExtraction.LumenRuleExtractor"><code>SolePostHoc.RuleExtraction.LumenRuleExtractor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract rules from a symbolic model using <a href="ref"><code>lumen</code></a>.</p><p>See also <a href="@ref"><code>modalextractrules</code></a>, <a href="@ref"><code>RuleExtractor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/rule-extraction.jl#L83-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.REFNERuleExtractor" href="#SolePostHoc.RuleExtraction.REFNERuleExtractor"><code>SolePostHoc.RuleExtraction.REFNERuleExtractor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract rules from a symbolic model using <a href="ref"><code>SolePostHoc.RuleExtraction.REFNE</code></a>.</p><p>See also <a href="@ref"><code>modalextractrules</code></a>, <a href="@ref"><code>RuleExtractor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/rule-extraction.jl#L120-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.RULECOSIPLUSRuleExtractor" href="#SolePostHoc.RuleExtraction.RULECOSIPLUSRuleExtractor"><code>SolePostHoc.RuleExtraction.RULECOSIPLUSRuleExtractor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract rules from a symbolic model using <a href="ref"><code>SolePostHoc.RuleExtraction.RULECOSIPLUS</code></a>.</p><p>See also <a href="@ref"><code>modalextractrules</code></a>, <a href="@ref"><code>RuleExtractor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/rule-extraction.jl#L158-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.TREPANRuleExtractor" href="#SolePostHoc.RuleExtraction.TREPANRuleExtractor"><code>SolePostHoc.RuleExtraction.TREPANRuleExtractor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extract rules from a symbolic model using <a href="ref"><code>SolePostHoc.RuleExtraction.TREPAN</code></a>.</p><p>See also <a href="@ref"><code>modalextractrules</code></a>, <a href="@ref"><code>RuleExtractor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/rule-extraction.jl#L139-L142">source</a></section></article><h3 id="Lumen"><a class="docs-heading-anchor" href="#Lumen">Lumen</a><a id="Lumen-1"></a><a class="docs-heading-anchor-permalink" href="#Lumen" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.Lumen.lumen-Tuple{Any}" href="#SolePostHoc.RuleExtraction.Lumen.lumen-Tuple{Any}"><code>SolePostHoc.RuleExtraction.Lumen.lumen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lumen(model; config_args...) -&gt; LumenResult
lumen(model, config::LumenConfig) -&gt; LumenResult</code></pre><p>Logic-driven Unified Minimal Extractor of Notions (LUMEN): Extract and minimize  logical rules from decision tree models into interpretable DNF formulas.</p><p>LUMEN implements a comprehensive pipeline for converting decision tree models into interpretable logical rules. The algorithm extracts the underlying decision logic, constructs truth tables, and applies advanced minimization techniques to produce compact, human-readable rule sets.</p><p><strong>Method Signatures</strong></p><p><strong>Keyword Arguments Interface</strong></p><pre><code class="language-julia hljs">lumen(model; minimization_scheme=:mitespresso, vertical=1.0, horizontal=1.0, ...)</code></pre><p>Convenient interface using keyword arguments with automatic config construction.</p><p><strong>Configuration Object Interface</strong></p><pre><code class="language-julia hljs">lumen(model, config::LumenConfig)</code></pre><p>Advanced interface using pre-constructed configuration for complex scenarios.</p><p><strong>Arguments</strong></p><p><strong>Required Arguments</strong></p><ul><li><code>model</code>: Decision tree model to analyze<ul><li><strong>Single trees</strong>: Individual decision tree models</li><li><strong>Ensembles</strong>: Random forests, gradient boosting, etc.</li><li><strong>Supported formats</strong>: DecisionTree.jl, SoleModels framework</li></ul></li></ul><p><strong>Configuration (via keywords or LumenConfig)</strong></p><ul><li><code>minimization_scheme::Symbol = :mitespresso</code>: DNF minimization algorithm</li><li><code>vertical::Float64 = 1.0</code>: Instance coverage parameter α ∈ (0,1]</li><li><code>horizontal::Float64 = 1.0</code>: Feature coverage parameter β ∈ (0,1]</li><li><code>ott_mode::Bool = false</code>: Enable memory-optimized processing</li><li><code>silent::Bool = false</code>: Suppress progress output</li><li><code>return_info::Bool = true</code>: Include detailed metadata in results</li></ul><p><strong>Returns</strong></p><p><code>LumenResult</code> containing:</p><ul><li><strong><code>decision_set</code></strong>: Collection of minimized logical rules</li><li><strong><code>info</code></strong>: Metadata including statistics and unminimized rules</li><li><strong><code>processing_time</code></strong>: Total algorithm execution time</li></ul><p><strong>Algorithm Pipeline</strong></p><p><strong>Phase 1: Model Analysis and Rule Extraction</strong></p><pre><code class="nohighlight hljs">Input Model → Rule Extraction → Logical Rule Set</code></pre><ul><li>Analyzes model structure (single tree vs ensemble)</li><li>Extracts decision paths as logical rules</li><li>Handles different model types with appropriate strategies</li></ul><p><strong>Phase 2: Alphabet Construction and Atom Processing</strong></p><pre><code class="nohighlight hljs">Logical Rules → Atom Extraction → Logical Alphabet</code></pre><ul><li>Identifies atomic logical conditions</li><li>Constructs vocabulary for formula building</li><li>Validates feature support and operator compatibility</li></ul><p><strong>Phase 3: Truth Table Generation</strong></p><pre><code class="nohighlight hljs">Model + Alphabet → Truth Combinations → Labeled Examples</code></pre><ul><li>Generates systematic input combinations</li><li>Evaluates model on each combination</li><li>Creates correspondence between inputs and outputs</li></ul><p><strong>Phase 4: DNF Construction and Minimization</strong></p><pre><code class="nohighlight hljs">Truth Table → DNF Formulas → Minimized Rules</code></pre><ul><li>Constructs DNF formulas for each decision class</li><li>Applies advanced minimization algorithms</li><li>Converts back to interpretable rule format</li></ul><p><strong>Performance Characteristics</strong></p><p><strong>Computational Complexity</strong></p><ul><li><strong>Time</strong>: O(2^k × n × d) where k=features, n=instances, d=tree depth</li><li><strong>Space</strong>: O(k × r) where r=number of rules</li><li><strong>Scalability</strong>: Optimized modes available for large datasets</li></ul><p><strong>Memory Usage</strong></p><ul><li><strong>Standard mode</strong>: Suitable for typical datasets (&lt; 20 features)</li><li><strong>Optimized mode</strong>: Memory-efficient processing for large problems</li><li><strong>Streaming capability</strong>: Future versions may support streaming processing</li></ul><p><strong>Advanced Features</strong></p><p><strong>Custom Processing</strong></p><pre><code class="language-julia hljs"># Custom alphabet filtering for domain expertise
custom_filter = alphabet -&gt; remove_irrelevant_features(alphabet)
config = LumenConfig(filteralphabetcallback = custom_filter)
result = lumen(model, config)</code></pre><p><strong>Performance Tuning</strong></p><pre><code class="language-julia hljs"># Memory-optimized processing for large datasets
config = LumenConfig(ott_mode = true, vertical = 0.8)

# Speed-optimized processing with basic minimization
config = LumenConfig(minimization_scheme = :abc, silent = true)</code></pre><p><strong>Analysis and Debugging</strong></p><pre><code class="language-julia hljs"># Full information retention for analysis
config = LumenConfig(return_info = true, controllo = true)
result = lumen(model, config)

# Access detailed statistics  
println(&quot;Rules before minimization: _(length(result.info.unminimized_ds.rules))&quot;)
println(&quot;Rules after minimization: _(length(result.decision_set.rules))&quot;)</code></pre><p><strong>Error Handling</strong></p><p>The algorithm implements comprehensive error handling:</p><p><strong>Configuration Validation</strong></p><ul><li>Parameter range checking (coverage parameters must be ∈ (0,1])</li><li>Algorithm availability verification  </li><li>Consistency validation across parameters</li></ul><p><strong>Processing Errors</strong></p><ul><li>Graceful handling of minimization failures</li><li>Fallback strategies for problematic formulas</li><li>Detailed error reporting with context</li></ul><p><strong>Model Compatibility</strong></p><ul><li>Automatic detection of supported model types</li><li>Clear error messages for unsupported formats</li><li>Suggestions for model preprocessing</li></ul><p><strong>Examples</strong></p><p><strong>Basic Usage</strong></p><pre><code class="language-julia hljs"># Simple rule extraction with default settings
model = build_tree(X, y)
result = lumen(model)
println(&quot;Extracted _(length(result.decision_set.rules)) rules&quot;)</code></pre><p><strong>Advanced Configuration</strong></p><pre><code class="language-julia hljs"># Customized processing for complex scenarios
config = LumenConfig(
    minimization_scheme = :boom,        # Aggressive minimization
    vertical = 0.9,                     # High instance coverage  
    horizontal = 0.8,                   # Moderate feature coverage
    ott_mode = true,                    # Memory optimization
    return_info = true                  # Full information retention
)
result = lumen(large_ensemble, config)</code></pre><p><strong>Performance Analysis</strong></p><pre><code class="language-julia hljs"># Detailed performance and quality analysis
result = lumen(model, LumenConfig(return_info = true))

# Analyze minimization effectiveness
stats = result.info.vectPrePostNumber
total_reduction = sum(pre - post for (pre, post) in stats)
avg_compression = mean(pre / post for (pre, post) in stats)

println(&quot;Total term reduction: total_reduction&quot;)
println(&quot;Average compression ratio: (round(avg_compression, digits=2))x&quot;)
println(&quot;Processing time: _(result.processing_time) seconds&quot;)</code></pre><p><strong>Implementation Notes</strong></p><p><strong>Design Principles</strong></p><ol><li><strong>Modularity</strong>: Each phase is independently testable and extensible</li><li><strong>Configurability</strong>: Extensive customization without code modification</li><li><strong>Performance</strong>: Multiple optimization strategies for different scenarios  </li><li><strong>Robustness</strong>: Comprehensive error handling and validation</li><li><strong>Usability</strong>: Clean interfaces with sensible defaults</li></ol><p><strong>Extensibility Points</strong></p><ul><li><strong>New minimization algorithms</strong>: Add via Val() dispatch system</li><li><strong>Custom model types</strong>: Extend rule extraction strategies  </li><li><strong>Domain-specific processing</strong>: Custom alphabet filters and apply functions</li><li><strong>Output formats</strong>: Additional result formatters and exporters</li></ul><p>See also: <a href="#SolePostHoc.RuleExtraction.Lumen.LumenConfig"><code>LumenConfig</code></a>, <a href="#SolePostHoc.RuleExtraction.Lumen.LumenResult"><code>LumenResult</code></a>, <a href="@ref"><code>extract_rules</code></a>, <a href="@ref"><code>minimize_formula</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/lumen/main.jl#L1575-L1773">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.Lumen.LumenConfig" href="#SolePostHoc.RuleExtraction.Lumen.LumenConfig"><code>SolePostHoc.RuleExtraction.Lumen.LumenConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LumenConfig</code></pre><p>Configuration parameters for the Logic-driven Unified Minimal Extractor of Notions (LUMEN) algorithm.</p><p>This struct encapsulates all configuration options for the LUMEN algorithm, providing a clean interface with automatic validation and sensible defaults. It uses Julia&#39;s <code>@kwdef</code> macro to enable keyword-based construction with default values.</p><p><strong>Fields</strong></p><p><strong>Core Algorithm Parameters</strong></p><ul><li><code>minimization_scheme::Symbol = :AlgorithmName</code>: The DNF minimization algorithm to use<ul><li><code>:mitespresso</code>: Advanced minimization with good balance of speed/quality</li><li><code>:boom</code>: Boom minimizator </li><li><code>:abc</code>: Minimization whit Berkeley framework </li></ul></li></ul><p><strong>Coverage Parameters</strong></p><ul><li><code>vertical::Float64 = 1.0</code>: Vertical coverage parameter (α) ∈ (0.0, 1.0] Controls how many instances must be covered by extracted rules</li><li><code>horizontal::Float64 = 1.0</code>: Horizontal coverage parameter (β) ∈ (0.0, 1.0]   Controls the breadth of rule coverage across feature space (% of different thresholds)</li></ul><p><strong>Processing Modes</strong></p><ul><li><code>ott_mode::Bool = false</code>: Optimized truth table processing When <code>true</code>, uses memory-efficient and time-efficient algorithms for large datasets</li><li><code>controllo::Bool = false</code>: Enable validation mode Compares results between different processing methods for correctness verification</li></ul><p><strong>Customization Options</strong></p><ul><li><code>minimization_kwargs::NamedTuple = (;)</code>: Additional parameters for minimization algorithms</li><li><code>filteralphabetcallback = identity</code>: Custom function to filter/modify the logical alphabet</li><li><code>apply_function = nothing</code>: Custom function for model application If <code>nothing</code>, automatically determined based on model type (with SoleModels)</li></ul><p><strong>Output Control</strong></p><ul><li><code>silent::Bool = false</code>: Suppress progress and diagnostic output</li><li><code>return_info::Bool = true</code>: Include additional metadata in results</li><li><code>vetImportance::Vector = []</code>: Vector for tracking feature importance values</li></ul><p><strong>Testing and Debugging</strong></p><ul><li><code>testott = nothing</code>: Special testing mode for optimization validation</li><li><code>alphabetcontroll = nothing</code>: Special mode for alphabet analysis only</li></ul><p><strong>Constructor Validation</strong></p><p>The constructor automatically validates parameters and throws descriptive errors:</p><ul><li>Coverage parameters must be in range (0.0, 1.0]</li><li>Minimization scheme must be supported</li><li>Inconsistent parameter combinations are caught early</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic usage with defaults
config = LumenConfig()

# Customized configuration
config = LumenConfig(
    minimization_scheme = :abc,
    vertical = 0.8,
    horizontal = 0.9,
    silent = true
)

# Advanced configuration with custom processing
config = LumenConfig(
    ott_mode = true,
    minimization_kwargs = (max_iterations = 1000,),
    filteralphabetcallback = my_custom_filter
)</code></pre><p>See also: <a href="../getting-started/#SolePostHoc.RuleExtraction.Lumen.lumen"><code>lumen</code></a>, <a href="#SolePostHoc.RuleExtraction.Lumen.LumenResult"><code>LumenResult</code></a>, <a href="@ref"><code>validate_config</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/lumen/main.jl#L28-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.Lumen.LumenResult" href="#SolePostHoc.RuleExtraction.Lumen.LumenResult"><code>SolePostHoc.RuleExtraction.Lumen.LumenResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LumenResult</code></pre><p>Comprehensive result structure containing extracted logical rules and associated metadata.</p><p>This immutable struct encapsulates all outputs from the LUMEN algorithm, providing a clean and extensible interface for accessing results. The design follows the principle of  returning rich, self-documenting results rather than simple tuples.</p><p><strong>Fields</strong></p><ul><li><code>decision_set::DecisionSet</code>: The primary output - a collection of minimized logical rules Each rule consists of a logical formula (antecedent) and a decision outcome (consequent)</li><li><code>info::NamedTuple</code>: Extensible metadata container with algorithm-specific information Common fields include:<ul><li><code>vectPrePostNumber</code>: Vector of (pre, post) minimization term counts</li><li><code>unminimized_ds</code>: Original decision set before minimization (if requested)</li><li><code>processing_time</code>: Total algorithm execution time</li><li><code>feature_importance</code>: Feature ranking information (if available)</li></ul></li><li><code>processing_time::Float64</code>: Total processing time in seconds Measured from algorithm start to completion, useful for performance analysis</li></ul><p><strong>Constructors</strong></p><p>Two constructors are provided for different use cases:</p><pre><code class="language-julia hljs"># Full constructor - for complete results with metadata
LumenResult(decision_set, info_tuple, processing_time)

# Minimal constructor - when only rules are available  
LumenResult(decision_set)  # info=empty, processing_time=0.0</code></pre><p><strong>Design Rationale</strong></p><p>This structured approach provides several advantages over returning raw tuples:</p><ol><li><strong>Self-documentation</strong>: Field names clearly indicate content</li><li><strong>Type safety</strong>: Julia&#39;s type system validates structure at compile time  </li><li><strong>Extensibility</strong>: Easy to add new fields without breaking existing code</li><li><strong>IDE support</strong>: Autocompletion and inline documentation</li><li><strong>Backward compatibility</strong>: Old code can still access fields by name</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic usage
result = lumen(model, config)
rules = result.decision_set
println(&quot;Extracted (length(rules.rules)) rules in (result.processing_time)s&quot;)

# Accessing metadata
if haskey(result.info, :vectPrePostNumber)
    stats = result.info.vectPrePostNumber
    total_reduction = sum(pre - post for (pre, post) in stats)
    println(&quot;Reduced formula complexity by 	otal_reduction terms&quot;)
end

# Comparing minimized vs original rules
if haskey(result.info, :unminimized_ds)
    original_rules = result.info.unminimized_ds
    println(&quot;Minimization: (length(original_rules.rules)) → (length(result.decision_set.rules))&quot;)
end</code></pre><p>See also: <a href="../getting-started/#SolePostHoc.RuleExtraction.Lumen.lumen"><code>lumen</code></a>, <a href="#SolePostHoc.RuleExtraction.Lumen.LumenConfig"><code>LumenConfig</code></a>, <a href="@ref"><code>DecisionSet</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/lumen/main.jl#L128-L196">source</a></section></article><h3 id="REFNE"><a class="docs-heading-anchor" href="#REFNE">REFNE</a><a id="REFNE-1"></a><a class="docs-heading-anchor-permalink" href="#REFNE" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.REFNE.refne-Tuple{Any, Any, Any}" href="#SolePostHoc.RuleExtraction.REFNE.refne-Tuple{Any, Any, Any}"><code>SolePostHoc.RuleExtraction.REFNE.refne</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refne(m, Xmin, Xmax; L=100, perc=1.0, max_depth=-1, n_subfeatures=-1, 
      partial_sampling=0.7, min_samples_leaf=5, min_samples_split=2, 
      min_purity_increase=0.0, seed=3)</code></pre><p>Extract interpretable rules from a trained neural network ensemble using decision tree approximation.</p><p>This implementation follows the REFNE-a (Rule Extraction From Neural Network Ensemble) algorithm, which approximates complex neural network behavior with an interpretable decision tree model.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: Trained neural network model to extract rules from</li><li><code>Xmin</code>: Minimum values for each input feature</li><li><code>Xmax</code>: Maximum values for each input feature</li><li><code>L</code>: Number of samples to generate in the synthetic dataset (default: 100)</li><li><code>perc</code>: Percentage of generated samples to use (default: 1.0)</li><li><code>max_depth</code>: Maximum depth of the decision tree (default: -1, unlimited)</li><li><code>n_subfeatures</code>: Number of features to consider at each split (default: -1, all)</li><li><code>partial_sampling</code>: Fraction of samples used for each tree (default: 0.7)</li><li><code>min_samples_leaf</code>: Minimum number of samples required at a leaf node (default: 5)</li><li><code>min_samples_split</code>: Minimum number of samples required to split a node (default: 2)</li><li><code>min_purity_increase</code>: Minimum purity increase required for a split (default: 0.0)</li><li><code>seed</code>: Random seed for reproducibility (default: 3)</li></ul><p><strong>Returns</strong></p><ul><li>A forest-decision trees representing the extracted rules</li></ul><p><strong>Description</strong></p><p>The algorithm works by:</p><ol><li>Generating a synthetic dataset spanning the input space</li><li>Using the neural network to label these samples</li><li>Training a decision tree to approximate the neural network&#39;s behavior</li></ol><p><strong>References</strong></p><ul><li>Zhi-Hua, Zhou, et al. Extracting Symbolic Rules from Trained Neural Network Ensembles</li></ul><p><strong>Example</strong></p><p>```julia model = load<em>decision</em>tree_model() refne(model, Xmin, Xmax)</p><p>See also <a href="@ref"><code>AbstractModel</code></a>, <a href="@ref"><code>DecisionList</code></a>, <a href="@ref"><code>listrules</code></a>, <a href="@ref"><code>rulemetrics</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/Refne/src/main.jl#L23-L69">source</a></section></article><h3 id="TREPAN"><a class="docs-heading-anchor" href="#TREPAN">TREPAN</a><a id="TREPAN-1"></a><a class="docs-heading-anchor-permalink" href="#TREPAN" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.TREPAN.trepan-Tuple{Any, Any}" href="#SolePostHoc.RuleExtraction.TREPAN.trepan-Tuple{Any, Any}"><code>SolePostHoc.RuleExtraction.TREPAN.trepan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><ul><li>Mark W. Craven, et al. &quot;Extracting Thee-Structured Representations of Thained Networks&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/Trepan/src/main.jl#L23-L25">source</a></section></article><h3 id="BATrees"><a class="docs-heading-anchor" href="#BATrees">BATrees</a><a id="BATrees-1"></a><a class="docs-heading-anchor-permalink" href="#BATrees" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.BATrees.batrees" href="#SolePostHoc.RuleExtraction.BATrees.batrees"><code>SolePostHoc.RuleExtraction.BATrees.batrees</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">batrees(f; dataset_name=&quot;iris&quot;, num_trees=10, max_depth=10, dsOutput=true)</code></pre><p>Builds and trains a set of binary decision trees OR using the specified function <code>f</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: An SoleForest.</li><li><code>dataset_name::String</code>: The name of the dataset to be used. Default is &quot;iris&quot;.</li><li><code>num_trees::Int</code>: The number of trees to be built. Default is 10.</li><li><code>max_depth::Int</code>: The maximum depth of each tree. Default is 10.</li><li><code>dsOutput::Bool</code>: A flag indicating whether to return the dsStruct output. Default is true. if false, returns the result single tree.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>dsOutput</code> is true, returns the result is in DecisionSet ds.</li><li>If <code>dsOutput</code> is false, returns the result is SoleTree t`.</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/BA-Trees/src/main.jl#L14-L31">source</a></section></article><h3 id="RULECOSIPLUS"><a class="docs-heading-anchor" href="#RULECOSIPLUS">RULECOSIPLUS</a><a id="RULECOSIPLUS-1"></a><a class="docs-heading-anchor-permalink" href="#RULECOSIPLUS" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SolePostHoc.RuleExtraction.RULECOSIPLUS.rulecosiplus-Tuple{Any, Any, Any}" href="#SolePostHoc.RuleExtraction.RULECOSIPLUS.rulecosiplus-Tuple{Any, Any, Any}"><code>SolePostHoc.RuleExtraction.RULECOSIPLUS.rulecosiplus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rulecosiplus(ensemble::Any, X_train::Any, y_train::Any)</code></pre><p>Extract interpretable rules from decision tree ensembles using the RuleCOSI+ algorithm.</p><p>This function implements the RuleCOSI+ methodology for rule extraction from trained ensemble  classifiers, producing a simplified and interpretable rule-based model. The method combines  and simplifies rules extracted from individual trees in the ensemble to create a more  compact and understandable decision list.</p><p><strong>Reference</strong></p><p>Obregon, J. (2022). RuleCOSI+: Rule extraction for interpreting classification tree ensembles.  <em>Information Fusion</em>, 89, 355-381.  Available at: https://www.sciencedirect.com/science/article/pii/S1566253522001129</p><p><strong>Arguments</strong></p><ul><li><code>ensemble::Any</code>: A trained ensemble classifier (e.g., Random Forest, Gradient Boosting)  that will be serialized and converted to a compatible format for rule extraction.</li><li><code>X_train::Any</code>: Training feature data. Can be a DataFrame or Matrix. If DataFrame,  column names will be preserved in the extracted rules; otherwise, generic names (V1, V2, ...)  will be generated.</li><li><code>y_train::Any</code>: Training target labels corresponding to <code>X_train</code>. Will be converted to  string format for processing.</li></ul><p><strong>Returns</strong></p><ul><li><code>DecisionList</code>: A simplified decision list containing the extracted and combined rules  from the ensemble, suitable for interpretable classification.</li></ul><p><strong>Details</strong></p><p>The function performs the following steps:</p><ol><li>Converts input data to appropriate matrix format</li><li>Generates or extracts feature column names</li><li>Serializes the Julia ensemble to a Python-compatible format</li><li>Builds an sklearn-compatible model using the serialized ensemble</li><li>Applies RuleCOSI+ algorithm with the following default parameters:<ul><li><code>metric=&quot;fi&quot;</code>: Optimization metric for rule combination</li><li><code>n_estimators=100</code>: Number of estimators considered</li><li><code>tree_max_depth=100</code>: Maximum depth of trees</li><li><code>conf_threshold=0.25</code> (α): Confidence threshold for rule filtering</li><li><code>cov_threshold=0.1</code> (β): Coverage threshold for rule filtering</li><li><code>verbose=2</code>: Detailed output during processing</li></ul></li><li>Extracts and converts rules to a decision list format</li></ol><p><strong>Configuration</strong></p><p>The algorithm uses fixed parameters optimized for interpretability:</p><ul><li>Confidence threshold (α) = 0.25: Rules below this confidence are discarded</li><li>Coverage threshold (β) = 0.1: Rules covering fewer samples are excluded</li><li>Maximum rules = max(20, n_classes × 5): Adaptive limit based on problem complexity</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Assuming you have a trained ensemble and training data
ensemble = ... # your trained ensemble
X_train = ... # training features
y_train = ... # training labels

# Extract interpretable rules
decision_list = rulecosiplus(ensemble, X_train, y_train)</code></pre><p><strong>Notes</strong></p><ul><li>The function prints diagnostic information including the number of trees and dataset statistics</li><li>Raw rules are displayed before conversion to decision list format</li><li>Requires Python interoperability and the RuleCOSI implementation</li><li>The resulting decision list provides an interpretable alternative to the original ensemble</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SolePostHoc.jl/blob/b418a95810f75677a09959785e09047688cb01a4/src/RuleCosiplus/src/main.jl#L361-L426">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting started</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 29 September 2025 21:46">Monday 29 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
